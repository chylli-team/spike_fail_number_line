.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test2::Harness::Runner::Preload 3"
.TH Test2::Harness::Runner::Preload 3 2023-10-03 "perl v5.38.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Test2::Harness::Runner::Preload \- DSL for building complex stage\-based preload
tools.
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Test2::Harness allows you to preload libraries for a performance boost. This
module provides tools that let you go beyond that and build a more complex
preload. In addition you can build multiple preload \fIstages\fR, each stage will
be its own process and tests can run from a specific stage. This allows for
multiple different preload states from which to run tests.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.SS "USING YOUR PRELOAD"
.IX Subsection "USING YOUR PRELOAD"
The \f(CW\*(C`\-P\*(C'\fR or \f(CW\*(C`\-\-preload\*(C'\fR options work for custom preload modules just as they
do regular modules. Yath will know the difference and act accordingly.
.PP
.Vb 1
\&    yath test \-PMy::Preload
.Ve
.SS "WRITING YOUR PRELOAD"
.IX Subsection "WRITING YOUR PRELOAD"
.Vb 3
\&    package My::Preload;
\&    use strict;
\&    use warnings;
\&
\&    # This imports several useful tools, and puts the necessary meta\-data in
\&    # your package to identify it as a special preload.
\&    use Test2::Harness::Runner::Preload;
\&
\&    # You must specify at least one stage.
\&    stage Moose => sub {
\&        # Preload can be called multiple times, and can load multiple modules
\&        # per call. Order is preserved.
\&        preload \*(AqMoose\*(Aq, \*(AqMoose::Role\*(Aq;
\&        preload \*(AqScalar::Util\*(Aq, \*(AqList::Util\*(Aq;
\&
\&        # preload can also be given a sub if you have some custom code to run
\&        # at a specific point in the load order
\&        preload sub {
\&            # Do something before loading Try::Tiny
\&            ...
\&        };
\&
\&        preload \*(AqTry::Tiny\*(Aq;
\&
\&        # Tell the runner to watch this file for changes, if it does change run
\&        # the sub instead of the usual reload process. This lets you reload
\&        # configs and other non\-perl files, or allows you to use a custom
\&        # reload sub for perl files.
\&        watch \*(Aqpath/to/file\*(Aq => sub { ... };
\&
\&        # You can also use watch inside preload subs:
\&        preload sub {
\&            watch \*(Aqpath/to/file\*(Aq => sub { ... };
\&        };
\&
\&        # In app code you can add watches dynamically when applicable:
\&        preload sub {
\&            ... # inside app code
\&
\&            if ($INC{\*(AqTest2/Harness/Runner/DepTracer.pm\*(Aq}) {
\&                if (my $active = Test2::Harness::Runner::DepTracer\->ACTIVE) {
\&                    $active\->add_callback(\*(Aqpath/to/file\*(Aq => sub { ... });
\&                }
\&            }
\&
\&            ...
\&        };
\&
\&        # Eager means tests from nested stages can be run in this stage as
\&        # well, this is useful if the nested stage takes a long time to load as
\&        # it allows yath to start running tests sooner instead of waiting for
\&        # the stage to finish loading. Once the nested stage is loaded tests
\&        # intended for it will start running from it instead.
\&        eager();
\&
\&        # default means this stage is the one to use if the test does not
\&        # specify a stage.
\&        default();
\&
\&        # These are hooks that let you run arbitrary code at specific points in
\&        # the process. pre_fork happens just before forking to run a test.
\&        # post_fork happens just after forking for a test. pre_launch happens
\&        # as late as possible before the test starts executing (post fork,
\&        # after $0 and other special state are reset).
\&        pre_fork sub { ... };
\&        post_fork sub { ... };
\&        pre_launch sub { ... };
\&
\&        # Stages can be nested, nested ones build off the previous stage, but
\&        # are in a forked process to avoid contaminating the parent.
\&        stage Types => sub {
\&            preload \*(AqMooseX::Types\*(Aq;
\&        };
\&    };
\&
\&    # Alternative stage that loads Moo instead of Moose
\&    stage Moo => sub {
\&        preload \*(AqMoo\*(Aq;
\&
\&        ...
\&    };
.Ve
.SS "HARNESS DIRECTIVES IN PRELOADS"
.IX Subsection "HARNESS DIRECTIVES IN PRELOADS"
If you use a staged preload, and the \-\-reload option, you can add 'CHURN'
directives to files in order to only reload sections you are working on. This
is particularly useful when a file cannot be reloaded in full, or when doing so
is expensive. You can wrap subroutines in the churn directives to have yath
reload only those subroutines.
.PP
.Vb 1
\&    sub do_not_reload_this { ... {
\&
\&    # HARNESS\-CHURN\-START
\&
\&    sub reload_this_one {
\&        ...
\&    }
\&
\&    sub reload_this_one_too {
\&        ...
\&    }
\&
\&    # HARNESS\-CHURN\-STOP
\&
\&    sub this_is_not_reloaded { ... }
.Ve
.PP
You can put as many churn sections you want in as many preloaded modules as you
want. If a change is detected then only the churn sections will be reloaded.
The churn sections are reloaded by taking the source between the start and stop
markers, and running them in an eval like this:
.PP
.Vb 9
\&    eval <<EOT
\&    package MODULE_FROM_FILENAME;
\&    use strict;
\&    use warnings;
\&    no warnings \*(Aqredefine\*(Aq;
\&    #line $line_number $file
\&    $YOUR_CODE
\&    ;1;
\&    EOT
.Ve
.PP
In most cases this is sufficient to replace the old sub with the new one. If
the automatically determined package is not correct you can add a \f(CW\*(C`package
FOO;\*(C'\fR statement inside the markers. If the strict/warnings settings are not to
your specifications you can add overrides inside the markers. Any valid perl
code can go into the markers.
.PP
\&\fBCAVEATS:\fR Be aware they do not have their original scope, and that can lead
to problems if you are not paying attention. Variables outside your markers are
not accessible, and lexical variables put inside your markers will be "new" on
each reload, this can cause confusion if you have lexicals used by multiple
subs where some are inside churn blocks and others are not, so best not to do
that. Package variables work a bit better, but any assignment lines are re-run.
So \f(CW\*(C`our $FOO;\*(C'\fR is fine (it does not change the value if it is set) but
\&\f(CW\*(C`our $FOO = ...\*(C'\fR will reset the var on each reload.
.SH EXPORTS
.IX Header "EXPORTS"
.ie n .IP "$meta = \fBTEST2_HARNESS_PRELOAD()\fR" 4
.el .IP "\f(CW$meta\fR = \fBTEST2_HARNESS_PRELOAD()\fR" 4
.IX Item "$meta = TEST2_HARNESS_PRELOAD()"
.PD 0
.ie n .IP "$meta = $class\->\fBTEST2_HARNESS_PRELOAD()\fR" 4
.el .IP "\f(CW$meta\fR = \f(CW$class\fR\->\fBTEST2_HARNESS_PRELOAD()\fR" 4
.IX Item "$meta = $class->TEST2_HARNESS_PRELOAD()"
.PD
This export provides the meta object, which is an instance of this class. This
method being present is how Test2::Harness differentiates between a regular
module and a special preload library.
.IP "stage NAME => sub { ... }" 4
.IX Item "stage NAME => sub { ... }"
This creates a new stage with the given \f(CW\*(C`NAME\*(C'\fR, and then runs the coderef with
the new stage set as the \fIactive\fR one upon which the other function here will
operate. Once the coderef returns the \fIactive\fR stage is cleared.
.Sp
You may nest stages by calling this function again inside the codeblock.
.Sp
\&\fBNOTE:\fR stage names \fBARE\fR case sensitive. This can be confusing when you
consider that most harness directives are all-caps. In the following case the
stage requested by the test and the stage defined in
the library are NOT the same.
.Sp
In a test file:
.Sp
.Vb 1
\&    # HARNESS\-STAGE\-FOO
.Ve
.Sp
In a preload library:
.Sp
.Vb 1
\&    stage foo { ... }
.Ve
.Sp
Harness directives are all-caps, however the user data portion need not be,
this is fine:
.Sp
.Vb 1
\&    # HARNESS\-STAGE\-foo
.Ve
.Sp
However it is very easy to make the mistake of thinking it is case insensitive.
It is also easy to assume the 'foo' part of the harness directive must be all
caps. In many cases it is smart to make your stage names all-caps.
.ie n .IP "preload $module_name" 4
.el .IP "preload \f(CW$module_name\fR" 4
.IX Item "preload $module_name"
.PD 0
.ie n .IP "preload @module_names" 4
.el .IP "preload \f(CW@module_names\fR" 4
.IX Item "preload @module_names"
.IP "preload sub { ... }" 4
.IX Item "preload sub { ... }"
.PD
This \fBMUST\fR be called inside a \f(CWstage()\fR builder coderef.
.Sp
This adds modules to the list of libraries to preload. Order is preserved. You
can also add coderefs to execute arbitrary code between module loads.
.Sp
The coderef is called with no arguments, and its return is ignored.
.IP \fBeager()\fR 4
.IX Item "eager()"
This \fBMUST\fR be called inside a \f(CWstage()\fR builder coderef.
.Sp
This marks the \fIactive\fR stage as being \fIeager\fR. An eager stage will start
running tests for nested stages if it finds itself with no tests of its own to
run before the nested stage can finish loading. The idea here is to avoid
unused test slots when possible allowing for tests to complete sooner.
.IP \fBdefault()\fR 4
.IX Item "default()"
This \fBMUST\fR be called inside a \f(CWstage()\fR builder coderef.
.Sp
This \fBMUST\fR be called only once across \f(CW\*(C`ALL\*(C'\fR stages in a given library.
.Sp
If multiple preload libraries are loaded then the \fIfirst\fR default set (based
on load order) will be the default, others will notbe honored.
.ie n .IP "$stage_name = file_stage($test_file)" 4
.el .IP "\f(CW$stage_name\fR = file_stage($test_file)" 4
.IX Item "$stage_name = file_stage($test_file)"
This is optional. If defined this callback will have a chance to look at all
files that are going to be run and assign them a stage. This may return undef
or an empty list if it does not have a stage to assign.
.Sp
If multiple preload libraries define file_stage callbacks they will be called
in order, the first one to return a stage name will win.
.Sp
If no file_stage callbacks provide a stage for a file then any harness
directives declaring a stage will be honored. If no stage is ever assigned then
the test will be run int he default stage.
.IP "pre_fork sub { ... }" 4
.IX Item "pre_fork sub { ... }"
This \fBMUST\fR be called inside a \f(CWstage()\fR builder coderef.
.Sp
Add a callback to be run just before the preload-stage process forks to run the
test. Note that any state changes here can effect future tests to be run.
.IP "post_fork sub { ... }" 4
.IX Item "post_fork sub { ... }"
This \fBMUST\fR be called inside a \f(CWstage()\fR builder coderef.
.Sp
Add a callback to be run just after the preload-stage process forks to run the
test. This is run as early as possible, things like \f(CW$0\fR may not be set
properly yet.
.IP "pre_launch sub { ... }" 4
.IX Item "pre_launch sub { ... }"
This \fBMUST\fR be called inside a \f(CWstage()\fR builder coderef.
.Sp
Add a callback to be run just before control of the test process is turned over
to the test file itself. This is run as late as possible, so things like \f(CW$0\fR
should be set properly.
.SH META-OBJECT
.IX Header "META-OBJECT"
This class is also the meta-object used to construct a preload library. The
methods are left undocumented as this is an implementation detail and you are
not intended to directly use this object.
.SH SOURCE
.IX Header "SOURCE"
The source code repository for Test2\-Harness can be found at
\&\fIhttp://github.com/Test\-More/Test2\-Harness/\fR.
.SH MAINTAINERS
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH AUTHORS
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright 2020 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
