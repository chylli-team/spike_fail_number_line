.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test2::Harness::Util 3"
.TH Test2::Harness::Util 3 2023-10-03 "perl v5.38.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Test2::Harness::Util \- General utiliy functions.
.SH DESCRIPTION
.IX Header "DESCRIPTION"
.SH METHODS
.IX Header "METHODS"
.SS MISC
.IX Subsection "MISC"
.ie n .IP "apply_encoding($fh, $enc)" 4
.el .IP "apply_encoding($fh, \f(CW$enc\fR)" 4
.IX Item "apply_encoding($fh, $enc)"
Apply the specified encoding to the filehandle.
.Sp
\&\fBJustification\fR:
PERLBUG 31923 <https://rt.perl.org/Public/Bug/Display.html?id=31923>
If utf8 is requested we use ':utf8' instead of ':encoding(utf8)' in
order to avoid the thread segfault.
.Sp
This is a reusable implementation of this:
.Sp
.Vb 6
\&    sub apply_encoding {
\&        my ($fh, $enc) = @_;
\&        return unless $enc;
\&        return binmode($fh, ":utf8") if $enc =~ m/^utf\-?8$/i;
\&        binmode($fh, ":encoding($enc)");
\&    }
.Ve
.ie n .IP "$clean = clean_path($path)" 4
.el .IP "\f(CW$clean\fR = clean_path($path)" 4
.IX Item "$clean = clean_path($path)"
Take a file path and clean it up to a minimal absolute path if possible. Always
returns a path, but if it cannot be cleaned up it is unchanged.
.ie n .IP "$hashref = find_libraries($search)" 4
.el .IP "\f(CW$hashref\fR = find_libraries($search)" 4
.IX Item "$hashref = find_libraries($search)"
.PD 0
.ie n .IP "$hashref = find_libraries($search, @paths)" 4
.el .IP "\f(CW$hashref\fR = find_libraries($search, \f(CW@paths\fR)" 4
.IX Item "$hashref = find_libraries($search, @paths)"
.PD
\&\f(CW@INC\fR is used if no \f(CW@paths\fR are provided.
.Sp
\&\f(CW$search\fR should be a module name with \f(CW\*(C`*\*(C'\fR wildcards replacing sections.
.Sp
.Vb 3
\&    find_libraries(\*(AqFoo::*::Baz\*(Aq)
\&    find_libraries(\*(Aq*::Bar::Baz\*(Aq)
\&    find_libraries(\*(AqFoo::Bar::*\*(Aq)
.Ve
.Sp
These all look for modules matching the search, this is a good way to find
plugins, or similar patterns.
.Sp
The result is a hashref of \f(CW\*(C`{ $module => $path }\*(C'\fR. If a module exists in
more than 1 search path the first is used.
.ie n .IP "$mod = fqmod($prefix, $mod)" 4
.el .IP "\f(CW$mod\fR = fqmod($prefix, \f(CW$mod\fR)" 4
.IX Item "$mod = fqmod($prefix, $mod)"
This will automatically add \f(CW$prefix\fR to \f(CW$mod\fR with \f(CW\*(Aq::\*(Aq\fR to join them. If
\&\f(CW$mod\fR starts with the \f(CW\*(Aq+\*(Aq\fR character the character will be removed and the
result returned without prepending \f(CW$prefix\fR.
.IP hub_truth 4
.IX Item "hub_truth"
This is an internal implementation detail, do not use it.
.ie n .IP "$hashref = parse_exit($?)" 4
.el .IP "\f(CW$hashref\fR = parse_exit($?)" 4
.IX Item "$hashref = parse_exit($?)"
This parses the exit value as typically stored in \f(CW$?\fR.
.Sp
Resulting hash:
.Sp
.Vb 6
\&    {
\&        sig => ($? & 127), # Signal value if the exit was caused by a signal
\&        err => ($? >> 8),  # Actual exit code, if any.
\&        dmp => ($? & 128), # Was there a core dump?
\&        all => $?,         # Original exit value, unchanged
\&    }
.Ve
.ie n .IP "@list = process_includes(%PARAMS)" 4
.el .IP "\f(CW@list\fR = process_includes(%PARAMS)" 4
.IX Item "@list = process_includes(%PARAMS)"
This method will build up a list of include dirs fit for \f(CW@INC\fR. The returned
list should contain only unique values, in proper order.
.Sp
Params:
.RS 4
.IP "list => \e@START" 4
.IX Item "list => @START"
Paths to start the new list.
.Sp
Optional.
.ie n .IP "ch_dir => $path" 4
.el .IP "ch_dir => \f(CW$path\fR" 4
.IX Item "ch_dir => $path"
Prefix to prepend to all paths in the \f(CW\*(C`list\*(C'\fR param. No effect without an
initial list.
.ie n .IP "include_current => $bool" 4
.el .IP "include_current => \f(CW$bool\fR" 4
.IX Item "include_current => $bool"
This will add all paths from \f(CW@INC\fR to the output, after the initial list.
Note that '.', if in \f(CW@INC\fR will be moved to the end of the final output.
.ie n .IP "clean => $bool" 4
.el .IP "clean => \f(CW$bool\fR" 4
.IX Item "clean => $bool"
If included all paths except \f(CW\*(Aq.\*(Aq\fR will be cleaned using \f(CWclean_path()\fR.
.ie n .IP "include_dot => $bool" 4
.el .IP "include_dot => \f(CW$bool\fR" 4
.IX Item "include_dot => $bool"
If true \f(CW\*(Aq.\*(Aq\fR will be appended to the end of the output.
.Sp
\&\fBNote\fR even if this is set to false \f(CW\*(Aq.\*(Aq\fR may still be included if it was in
the initial list, or if it was in \f(CW@INC\fR and \f(CW@INC\fR was included using the
\&\f(CW\*(C`include_current\*(C'\fR parameter.
.RE
.RS 4
.RE
.SS "FOR DEALING WITH MODULE <\-> FILE CONVERSION"
.IX Subsection "FOR DEALING WITH MODULE <-> FILE CONVERSION"
These convert between module names like \f(CW\*(C`Foo::Bar\*(C'\fR and filenames like
\&\f(CW\*(C`Foo/Bar.pm\*(C'\fR.
.ie n .IP "$file = mod2file($mod)" 4
.el .IP "\f(CW$file\fR = mod2file($mod)" 4
.IX Item "$file = mod2file($mod)"
.PD 0
.ie n .IP "$mod = file2mod($file)" 4
.el .IP "\f(CW$mod\fR = file2mod($file)" 4
.IX Item "$mod = file2mod($file)"
.PD
.SS "FOR READING/WRITING FILES"
.IX Subsection "FOR READING/WRITING FILES"
.ie n .IP "$fh = open_file($path, $mode)" 4
.el .IP "\f(CW$fh\fR = open_file($path, \f(CW$mode\fR)" 4
.IX Item "$fh = open_file($path, $mode)"
.PD 0
.ie n .IP "$fh = open_file($path)" 4
.el .IP "\f(CW$fh\fR = open_file($path)" 4
.IX Item "$fh = open_file($path)"
.PD
If no mode is provided \f(CW\*(Aq<\*(Aq\fR is assumed.
.Sp
This will open the file at \f(CW$path\fR and return a filehandle.
.Sp
An exception will be thrown if the file cannot be opened.
.Sp
\&\fBNOTE:\fR This will automatically use IO::Uncompress::Bunzip2 or
IO::Uncompress::Gunzip to uncompress the file if it has a .bz2 or .gz
extension.
.ie n .IP "$text = read_file($file)" 4
.el .IP "\f(CW$text\fR = read_file($file)" 4
.IX Item "$text = read_file($file)"
This will open the file at \f(CW$path\fR and return all its contents.
.Sp
An exception will be thrown if the file cannot be opened.
.Sp
\&\fBNOTE:\fR This will automatically use IO::Uncompress::Bunzip2 or
IO::Uncompress::Gunzip to uncompress the file if it has a .bz2 or .gz
extension.
.ie n .IP "$fh = maybe_open_file($path)" 4
.el .IP "\f(CW$fh\fR = maybe_open_file($path)" 4
.IX Item "$fh = maybe_open_file($path)"
.PD 0
.ie n .IP "$fh = maybe_open_file($path, $mode)" 4
.el .IP "\f(CW$fh\fR = maybe_open_file($path, \f(CW$mode\fR)" 4
.IX Item "$fh = maybe_open_file($path, $mode)"
.PD
If no mode is provided \f(CW\*(Aq<\*(Aq\fR is assumed.
.Sp
This will open the file at \f(CW$path\fR and return a filehandle.
.Sp
\&\f(CW\*(C`undef\*(C'\fR is returned if the file cannot be opened.
.Sp
\&\fBNOTE:\fR This will automatically use IO::Uncompress::Bunzip2 or
IO::Uncompress::Gunzip to uncompress the file if it has a .bz2 or .gz
extension.
.ie n .IP "$text = maybe_read_file($path)" 4
.el .IP "\f(CW$text\fR = maybe_read_file($path)" 4
.IX Item "$text = maybe_read_file($path)"
This will open the file at \f(CW$path\fR and return all its contents.
.Sp
This will return \f(CW\*(C`undef\*(C'\fR if the file cannot be opened.
.Sp
\&\fBNOTE:\fR This will automatically use IO::Uncompress::Bunzip2 or
IO::Uncompress::Gunzip to uncompress the file if it has a .bz2 or .gz
extension.
.ie n .IP "@content = write_file($path, @content)" 4
.el .IP "\f(CW@content\fR = write_file($path, \f(CW@content\fR)" 4
.IX Item "@content = write_file($path, @content)"
Write content to the specified file. This will open the file with mode
\&\f(CW\*(Aq>\*(Aq\fR, write the content, then close the file.
.Sp
An exception will be thrown if any part fails.
.ie n .IP "@content = write_file_atomic($path, @content)" 4
.el .IP "\f(CW@content\fR = write_file_atomic($path, \f(CW@content\fR)" 4
.IX Item "@content = write_file_atomic($path, @content)"
This will open a temporary file, write the content, close the file, then rename
the file to the desired \f(CW$path\fR. This is essentially an atomic write in that
\&\f(CW$file\fR will not exist until all content is written, preventing other
processes from doing a partial read while \f(CW@content\fR is being written.
.SH SOURCE
.IX Header "SOURCE"
The source code repository for Test2\-Harness can be found at
\&\fIhttp://github.com/Test\-More/Test2\-Harness/\fR.
.SH MAINTAINERS
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH AUTHORS
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright 2020 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
