.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test2::Manual::Tooling::Nesting 3"
.TH Test2::Manual::Tooling::Nesting 3 2023-10-25 "perl v5.38.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Test2::Manual::Tooling::Nesting \- Tutorial for using other tools within your
own.
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Sometimes you find yourself writing the same test pattern over and over, in
such cases you may want to encapsulate the logic in a new test function that
calls several tools together. This sounds easy enough, but can cause headaches
if not done correctly.
.SH "NAIVE WAY"
.IX Header "NAIVE WAY"
Lets say you find yourself writing the same test pattern over and over for multiple objects:
.PP
.Vb 3
\&    my $obj1 = $class1\->new;
\&    is($obj1\->foo, \*(Aqfoo\*(Aq, "got foo");
\&    is($obj1\->bar, \*(Aqbar\*(Aq, "got bar");
\&
\&    my $obj2 = $class1\->new;
\&    is($obj2\->foo, \*(Aqfoo\*(Aq, "got foo");
\&    is($obj2\->bar, \*(Aqbar\*(Aq, "got bar");
\&
\&    ... 10x more times for classes 2\-12
.Ve
.PP
The naive way to do this is to write a \f(CWcheck_class()\fR function like this:
.PP
.Vb 6
\&    sub check_class {
\&        my $class = shift;
\&        my $obj = $class\->new;
\&        is($obj\->foo, \*(Aqfoo\*(Aq, "got foo");
\&        is($obj\->bar, \*(Aqbar\*(Aq, "got bar");
\&    }
\&
\&    check_class($class1);
\&    check_class($class2);
\&    check_class($class3);
\&    ...
.Ve
.PP
This will appear to work fine, and you might not notice any problems,
\&\fIso long as the tests are passing.\fR
.SS "WHATS WRONG WITH IT?"
.IX Subsection "WHATS WRONG WITH IT?"
The problems with the naive approach become obvious if things start to fail.
The diagnostics that tell you what file and line the failure occurred on will be
wrong. The failure will be reported to the line \fIinside\fR \f(CW\*(C`check_class\*(C'\fR, not
to the line where \f(CWcheck_class()\fR was called. This is problem because it
leaves you with no idea which class is failing.
.SS "HOW TO FIX IT"
.IX Subsection "HOW TO FIX IT"
Luckily this is extremely easy to fix. You need to acquire a context object at
the start of your function, and release it at the end... yes it is that simple.
.PP
.Vb 1
\&    use Test2::API qw/context/;
\&
\&    sub check_class {
\&        my $class = shift;
\&
\&        my $ctx = context();
\&
\&        my $obj = $class\->new;
\&        is($obj\->foo, \*(Aqfoo\*(Aq, "got foo");
\&        is($obj\->bar, \*(Aqbar\*(Aq, "got bar");
\&
\&        $ctx\->release;
\&    }
.Ve
.PP
See, that was easy. With these 2 additional lines we know have proper file+line
reporting. The nested tools will find the context we acquired here, and know to
use it's file and line numbers.
.PP
\fITHE OLD WAY (DO NOT DO THIS ANYMORE)\fR
.IX Subsection "THE OLD WAY (DO NOT DO THIS ANYMORE)"
.PP
With Test::Builder there was a global variables called
\&\f(CW$Test::Builder::Level\fR which helped solve this problem:
.PP
.Vb 2
\&    sub check_class {
\&        my $class = shift;
\&
\&        local $Test::Builder::Level = $Test::Builder::Level + 1;
\&
\&        my $obj = $class\->new;
\&        is($obj\->foo, \*(Aqfoo\*(Aq, "got foo");
\&        is($obj\->bar, \*(Aqbar\*(Aq, "got bar");
\&    }
.Ve
.PP
This variable worked well enough (and will still work) but was not very
discoverable. Another problem with this variable is that it becomes cumbersome
if you have a more deeply nested code structure called the nested tools, you
might need to count stack frames, and hope they never change due to a third
party module. The context solution has no such caveats.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test2::Manual \- Primary index of the manual.
.SH SOURCE
.IX Header "SOURCE"
The source code repository for Test2\-Manual can be found at
\&\fIhttps://github.com/Test\-More/Test2\-Suite/\fR.
.SH MAINTAINERS
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH AUTHORS
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright 2018 Chad Granum <exodist@cpan.org>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
