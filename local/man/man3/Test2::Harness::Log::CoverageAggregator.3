.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test2::Harness::Log::CoverageAggregator 3"
.TH Test2::Harness::Log::CoverageAggregator 3 2023-10-03 "perl v5.38.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Test2::Harness::Log::CoverageAggregator \- Module for aggregating coverage data
from a stream of events.
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module takes a stream of events and produces aggregated coverage data.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    use Test2::Harness::Log::CoverageAggregator;
\&
\&    my $agg = Test2::Harness::Log::CoverageAggregator\->new();
\&
\&    while (my $e = $log\->next_event) {
\&        $agg\->process_event($e);
\&    }
\&
\&    # Get a structure like { source_file => { source_method => $touched_count, ... }, ...}
\&    my $touched_source = $agg\->touched;
\&
\&    # Get a structure like
\&    # {
\&    #     files => {total => 5,  tested => 2},
\&    #     subs  => {total => 20, tested => 12},
\&    #     untested => {files => \e@file_list, subs => {file => \e@sub_list, ...}},
\&    # }
\&    my $metrics = $agg\->metrics;
.Ve
.SH METHODS
.IX Header "METHODS"
.SS "IMPLEMENTABLE IN SUBLCASSES"
.IX Subsection "IMPLEMENTABLE IN SUBLCASSES"
If you implement these in a subclass they will be called for you at the proper
times, making subclassing much easier. In most cases you can avoid overriding
\&\fBprocess_event()\fR.
.ie n .IP "$agg\->start_test($test, $event)" 4
.el .IP "\f(CW$agg\fR\->start_test($test, \f(CW$event\fR)" 4
.IX Item "$agg->start_test($test, $event)"
This is called once per test when it starts.
.Sp
\&\fBNote:\fR If a test is run more than once (re-run) it will start and stop again
for each re-run. The event is also provided as an argument so that you can
check for a try-id or similar in the event that re-runs matter to you.
.ie n .IP "$agg\->stop_test($test, $event)" 4
.el .IP "\f(CW$agg\fR\->stop_test($test, \f(CW$event\fR)" 4
.IX Item "$agg->stop_test($test, $event)"
This is called once per test when it stops.
.Sp
\&\fBNote:\fR If a test is run more than once (re-run) it will start and stop again
for each re-run. The event is also provided as an argument so that you can
check for a try-id or similar in the event that re-runs matter to you.
.ie n .IP "$agg\->record_coverage($test, $coverage_data, $event)" 4
.el .IP "\f(CW$agg\fR\->record_coverage($test, \f(CW$coverage_data\fR, \f(CW$event\fR)" 4
.IX Item "$agg->record_coverage($test, $coverage_data, $event)"
This is called once per coverage event (there can be several in a test,
specially if it forks or uses threads).
.Sp
In most cases you probably want to leave this unimplemented and implement the
\&\f(CWtouch()\fR method instead of iterating over the coverage structure yourself.
.ie n .IP "$agg\->touch(source => $file, sub => $sub, test => $test, manager_data => $mdata, event => $event)" 4
.el .IP "\f(CW$agg\fR\->touch(source => \f(CW$file\fR, sub => \f(CW$sub\fR, test => \f(CW$test\fR, manager_data => \f(CW$mdata\fR, event => \f(CW$event\fR)" 4
.IX Item "$agg->touch(source => $file, sub => $sub, test => $test, manager_data => $mdata, event => $event)"
Every touch applied to a source file (and sub) will trigger this method call.
.RS 4
.ie n .IP "source => $file" 4
.el .IP "source => \f(CW$file\fR" 4
.IX Item "source => $file"
The source file that was touched
.ie n .IP "sub => $sub" 4
.el .IP "sub => \f(CW$sub\fR" 4
.IX Item "sub => $sub"
The source subroutine that was touched. \fBNote:\fR This may be '<>' if the source
file was opened via \f(CWopen()\fR or '*' if code outside of a subroutine was
executed by the test.
.ie n .IP "test => $test" 4
.el .IP "test => \f(CW$test\fR" 4
.IX Item "test => $test"
The test file that did the touching.
.ie n .IP "manager_data => $mdata" 4
.el .IP "manager_data => \f(CW$mdata\fR" 4
.IX Item "manager_data => $mdata"
If the test file makes use of a source manager to attach extra data to
coverage, this is where that data will be. A good example would be test suites
that use tools similar to Test::Class or Test::Class::Moose where all tests are
run in methods and you want to track what test method does the touching. Please
note that this level of coverage tracking is not automatic.
.ie n .IP "event => $event" 4
.el .IP "event => \f(CW$event\fR" 4
.IX Item "event => $event"
The full event being processed.
.RE
.RS 4
.RE
.SS "PUBLIC API"
.IX Subsection "PUBLIC API"
.ie n .IP $agg\->process_event($event) 4
.el .IP \f(CW$agg\fR\->process_event($event) 4
.IX Item "$agg->process_event($event)"
Process the event, aggregating any coverage info it may contain.
.ie n .IP "$touched = $add\->\fBtouched()\fR" 4
.el .IP "\f(CW$touched\fR = \f(CW$add\fR\->\fBtouched()\fR" 4
.IX Item "$touched = $add->touched()"
Returns the following structure, which tells you how many times a specific
source file's subroutines were called. There are also "special" subroutines
\&'<>' and '*' which mean "file was opened via open" and "code outside of a
subroutine".
.Sp
.Vb 7
\&    {
\&        source_file => {
\&            source_method => $touched_count,
\&            ...
\&        },
\&        ...
\&    }
.Ve
.ie n .IP "$metrics = $agg\->\fBbuild_metrics()\fR" 4
.el .IP "\f(CW$metrics\fR = \f(CW$agg\fR\->\fBbuild_metrics()\fR" 4
.IX Item "$metrics = $agg->build_metrics()"
.PD 0
.ie n .IP "$metrics = $agg\->build_metrics(exclude_private => $BOOL)" 4
.el .IP "\f(CW$metrics\fR = \f(CW$agg\fR\->build_metrics(exclude_private => \f(CW$BOOL\fR)" 4
.IX Item "$metrics = $agg->build_metrics(exclude_private => $BOOL)"
.PD
Will build metrics, and include them in the output from \f(CW\*(C`$agg\->coverage()\*(C'\fR
next time it is called.
.Sp
The \f(CW\*(C`exclude_private\*(C'\fR option, when set to true, will exclude any method that
beings with an underscore from the coverage metrics and untested sub list.
.Sp
Metrics:
.Sp
.Vb 3
\&    {
\&        files => {total => 20, tested => 18},
\&        subs  => {total => 80, tested => 70},
\&
\&        untested => {
\&            files => \e@file_list,
\&            subs => {
\&                file => \e@sub_list,
\&                ...
\&            }
\&        },
\&    }
.Ve
.SH SOURCE
.IX Header "SOURCE"
The source code repository for Test2\-Harness can be found at
\&\fIhttp://github.com/Test\-More/Test2\-Harness/\fR.
.SH MAINTAINERS
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH AUTHORS
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright 2020 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
