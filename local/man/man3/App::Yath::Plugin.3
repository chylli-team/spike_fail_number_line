.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "App::Yath::Plugin 3"
.TH App::Yath::Plugin 3 2023-10-03 "perl v5.38.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
App::Yath::Plugin \- Base class for yath plugins
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This is a base class for yath plugins. Note this class also subclasses
Test2::Harness::Plugin.
.PP
This class holds the methods specific to yath, which is the UI layer.
Test2::Harness::Plugin holds the methods specific to Test2::Harness which
is the backend.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    package App::Yath::Plugin::MyPlugin;
\&
\&    use parent \*(AqApp::Yath::Plugin\*(Aq;
\&
\&    # ... Define methods
\&
\&    1;
.Ve
.PP
Then to use it at the command line:
.PP
.Vb 1
\&    $ yath \-pMyPlugin ...
.Ve
.SH "NOTE ON INSTANCE VS CLASS"
.IX Header "NOTE ON INSTANCE VS CLASS"
None of the plugin base classes provide a \f(CWnew()\fR method. By default plugins
are not instantiated and only the plugin package name is passed around. All
methods are then called on the class.
.PP
If you want your plugin to be instantiated as an object you need only define a
\&\f(CWnew()\fR method. If this method is defined yath will call it and create an
instance. The instance created will then be used when calling all the methods.
.PP
To pass arguments to the constructor you can use
\&\f(CW\*(C`yath \-pYourPlugin=arg1,arg2,arg3...\*(C'\fR. Your plugin can also define options
using App::Yath::Options which will be dropped into the \f(CW$settings\fR that
get passed around.
.SH METHODS
.IX Header "METHODS"
\&\fBNote:\fR See Test2::Harness::Plugin for additional method you can implement/override
.ie n .IP "$plugin\->handle_event($event, $settings)" 4
.el .IP "\f(CW$plugin\fR\->handle_event($event, \f(CW$settings\fR)" 4
.IX Item "$plugin->handle_event($event, $settings)"
Called for every single event that yath sees. Note that this method is not
defined by default for performance reasons, however it will be called if you
define it.
.ie n .IP "@sorted = $plugin\->sort_files_2(settings => $settings, files => \e@unsorted)" 4
.el .IP "\f(CW@sorted\fR = \f(CW$plugin\fR\->sort_files_2(settings => \f(CW$settings\fR, files => \e@unsorted)" 4
.IX Item "@sorted = $plugin->sort_files_2(settings => $settings, files => @unsorted)"
This gives your plugin a chance to sort the files before they are added to the
queue. Other things are done later to re-order the files optimally based on
length or category, so this sort is just for initial job numbering, and to
define a base order before optimization takes place.
.Sp
All files to sort will be instances of Test2::Harness::TestFile.
.Sp
This method is normally left undefined, but will be called if you define it.
.Sp
If this is present then \f(CWsort_files()\fR will be ignored.
.ie n .IP "@sorted = $plugin\->sort_files(@unsorted)" 4
.el .IP "\f(CW@sorted\fR = \f(CW$plugin\fR\->sort_files(@unsorted)" 4
.IX Item "@sorted = $plugin->sort_files(@unsorted)"
\&\fBDEPRECATED\fR Use \f(CWsort_files_2()\fR instead.
.Sp
This gives your plugin a chance to sort the files before they are added to the
queue. Other things are done later to re-order the files optimally based on
length or category, so this sort is just for initial job numbering, and to
define a base order before optimization takes place.
.Sp
All files to sort will be instances of Test2::Harness::TestFile.
.Sp
This method is normally left undefined, but will be called if you define it.
.ie n .IP $plugin\->finish(%args) 4
.el .IP \f(CW$plugin\fR\->finish(%args) 4
.IX Item "$plugin->finish(%args)"
This is what arguments are recieved:
.Sp
.Vb 7
\&    (
\&        settings     => $settings,                      # The settings
\&        final_data   => $final_data,                    # See below
\&        pass         => $pass ? 1 : 0,                  # Always a 0 or 1
\&        tests_seen   => $self\->{+TESTS_SEEN} // 0,      # Integer 0 or greater
\&        asserts_seen => $self\->{+ASSERTS_SEEN} // 0,    # Integer 0 or greater
\&    )
.Ve
.Sp
The final_data looks like this, note that some data may not be present if it is
not applicable. The data structure can be as simple as
\&\f(CW\*(C`{ pass => $bool }\*(C'\fR.
.Sp
.Vb 2
\&    {
\&        pass => $pass,    # boolean, did the test run pass or fail?
\&
\&        failed => [       # Jobs that failed, and did not pass on a retry
\&            [$job_id1, $file1],    # Failing job 1
\&            [$job_id2, $file2],    # Failing job 2
\&            ...
\&        ],
\&        retried => [               # Jobs that failed and were retried
\&            [$job_id1, $times_run1, $file1, $passed_eventually1],    # Passed_eventually is a boolean
\&            [$job_id2, $times_run2, $file2, $passed_eventually2],
\&            ...
\&        ],
\&        hatled => [                                                  # Jobs that caused the entire test suite to halt
\&            [$job_id1, $file1, $halt_reason1],                       # halt_reason is a human readible string
\&            [$job_id2, $file2, $halt_reason2],
\&        ],
\&    }
.Ve
.ie n .IP $plugin\->finalize($settings) 4
.el .IP \f(CW$plugin\fR\->finalize($settings) 4
.IX Item "$plugin->finalize($settings)"
This is called as late as possible before exit. This is mainly useful for
outputting messages such as "Extra log file written to ..." which are best put
at the end of output.
.SH SOURCE
.IX Header "SOURCE"
The source code repository for Test2\-Harness can be found at
\&\fIhttp://github.com/Test\-More/Test2\-Harness/\fR.
.SH MAINTAINERS
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH AUTHORS
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright 2020 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
